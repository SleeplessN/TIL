# 2022/09/01

## 오늘 공부한 내용

### [프로미스](https://github.com/SleeplessN/TIL/blob/main/Javascript/Javascript%20DeepDive/45%EC%9E%A5%20%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4.md)

### [제너레이터와 async/await](https://github.com/SleeplessN/TIL/blob/main/Javascript/Javascript%20DeepDive/46%EC%9E%A5%20%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EC%99%80%20async%20await.md)

## 수업 내용

- 타이머
    - `setTimeout`이 콜백함수를 호출하는 것이 아니다.
        - `setTimeout`이 호출하면 그것은 동기 방식이다.
    - 호출 하는 것이란 실행 컨텍스트(콜스택)에 들어가는 것을 의미한다
    - 브라우저는 (현재 시간 - `setTimeout` 함수가 호출된 시간)을 계산해서 두번째 인자인 delay 값과 같아지면 **브라우저가** 콜백함수를 태스크 큐로 넣는다.
    - delay 이후 태스크 큐로 보내는 시간과, 콜 스택이 비워져야 해당 콜백 함수가 콜 스택에 쌓여서 실행되기 때문에 정확히는 delay 시간 이상 걸린다.
- 자바스크립트가 싱글 스레드가 아니라 자바스크립트 엔진, 정확히는 콜스택이 싱글 스레드이다
    - 결국 자바스크립트는 멀티 스레드이다
    - 멀티 스레드는 공동 자원을 같이 접근할 수 있기 때문에 매우 조심스럽다.
    - 동시성을 놓칠 수 없기 때문에 비동기를 사용한다.
- 비동기를 사용하는 이유의 대부분은 서버와의 통신 때문이다
    - 서버가 응답을 해주는데 걸리는 시간이 존재하기 때문
- 브라우저(`Client`)는 View를 구현하기 위함인데 그 내용(HTML, CSS, JS, img, font 등등)은 다 `Server`가 가지고 있다.
    - 이런 통신하는 방식을 통일한 것이 HTTP protocol 이다
    - 요청 방식을 “ex. GET URL 의 방식으로 하자” 라고 약속하는 것이 REST API이다.
    - 왜 알아야하나? 백엔드와 커뮤니케이션 때문이다 (협업을 위함)
- Express를 사용하여 웹 서버를 만들어볼 얘정
- fetch든 axios든 결국 XMLHttpRequest 기반이다
    - 하지만 axios를 사용한다
- XMLHttpRequest
    - XMLHttpRequest은 요즘은 JSON으로 변환하여 통신하는데 그 전에는 XML으로 변환하여 통신했기 때문에 XML이 붙어있는 것이다.
        - 요즘 XML 사용하는 일은 극히 드물다
    - xhr이 발생하는 ‘load’와 이벤트 타입의 ‘load’는 이름이 같은 것이고 다른 것이다.
    - HTTP status 코드
        - `200`번대는 성공 ⇒ 대부분 200이고 가끔 201(created)
        - `400`번대는 실패 ⇒ 오류 (요청을 잘못함)
        - `500`번대는 실패 ⇒ 오류 (서버상의 오류)
    - GET 요청시 favicon은 자동으로 요청이 된다.
    - 콜백 함수는 같은 함수 내에서 함수를 조합하는 방식이다.
    - return 값은 `caller`가 받을 수 있다.
        - 명시적으로 호출을 하지 않으면 리턴값을 못 받는다.
        - 이벤트 핸들러 호출을 브라우저(`caller`)가 한다. 그래서 우리는 리턴값을 받을 수 없다.
- 제너레이터는 예를 들어 linked list 의 `Symbol.iterator`를 구현할 때 사용하면 간단하게 구현할 수 있다.
- Babel은 ES6 이상의 문법을 ES5 이하의 문법으로 바꿔준다.
- `async / await` 는 값을 받아올 생각을 해야지 바깥으로 나올려고 하면 안된다. 그렇게 할 경우에는 제너레이터를 사용하는 것이다. 단지 원리만 같을뿐이다
- 결론은 `async / await`를 사용하자!!
    - 하지만 후속처리로 프로미스를 사용하는 일이 있으므로 프로미스를 배워야한다.
- **에러처리**는 상~당히 중요하다!
    - 에러는 발생하게 되어있다. 그것을 빨리 고치기 위해서는 빨리 감지해야 한다
    - 에러를 어디서 잡을까?
        - 에러를 발생한 곳에서 잡을 것인가?
        - Top level 에서 잡을 것인가?
            - 에러가 caller로 전파가 되어야 한다
                - 문제는 이 함수의 caller가 누군가?
    - 콜백 함수의 경우 반드시 그 쪽에서 해야한다.
        
        
- 정리
    - 값을 바깥으로 가져올 수 없기 때문에 콜백을 사용했다
        - 하지만 이는 **콜백 헬**(가독성 문제)을 발생시키고 에러 처리가 불가능해졌다.
    - 이를 모두 해결한 것이 **async / await** 방식을 사용한다
        - await는 변수로 받을 수 있다.
        - try에서는 resolve에서의 프로미스 value 값을 받는다.
        - catch에서는 reject에서의 프로미스 value 값을 받는다.
    - ⭐️ 반드시 `try … catch`를 사용해주어야 한다!

## 느낀점

- 자바스크립트가, 아니 정확히는 자바스크립트 엔진이 싱글 스레드임에도 비동기로 작동할 수 있는 이유가 이전에는 그냥 그런가보다라고 이해했지만 자바스크립트 엔진은 싱글 스레드(콜 스택이 한 개)이지만, 크게 보면 자바스크립트는 결국 브라우저를 포함하기 때문에 동기 방식(멀티 스레드)을 사용할 수 있다는 것을 알게되었다. 하지만 멀티스레드 방식은 공동 자원에 동시에 접근할 수 있는 문제 등이 있기 때문에 조심해서 사용해야 한다. 그렇기 때문에 결국 코드를 작성할 경우에 정확히 어떤 것이 동기적으로 호출되며 어떤 것이 비동기적으로 호출 되는지 알아야한다.
- 프로미스에 대해서 개념이 확실하게 잡히지 않았는데 러버덕을 통해서 프로미스가 정확히 어떠한 방식으로 동작하는지 알게되었다. 하지만 결국 프로미스도 콜백 패턴으로 동작하고, 가독성이 좋지만은 않아서 요즘에는 이 모든 단점을 보완한 async / await 방식을 사용한다는 것을 알게되었다.