# 2022/08/16

## 오늘 공부한 내용

### [프로퍼티 어트리뷰트](https://github.com/SleeplessN/TIL/blob/main/Javascript/Javascript%20DeepDive/16%EC%9E%A5%20%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%20%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8.md)

### [생성자 함수에 의한 객체 생성](https://github.com/SleeplessN/TIL/blob/main/Javascript/Javascript%20DeepDive/17%EC%9E%A5%20%EC%83%9D%EC%84%B1%EC%9E%90%20%ED%95%A8%EC%88%98%EC%97%90%20%EC%9D%98%ED%95%9C%20%EA%B0%9D%EC%B2%B4%20%EC%83%9D%EC%84%B1.md)

### [함수와 일급 객체](https://github.com/SleeplessN/TIL/blob/main/Javascript/Javascript%20DeepDive/18%EC%9E%A5%20%ED%95%A8%EC%88%98%EC%99%80%20%EC%9D%BC%EA%B8%89%20%EA%B0%9D%EC%B2%B4.md)

## 수업 내용

- 이 책에서 가장 중요한 부분 1st. for문(반복문), 2nd 렉시컬 스코프
- 함수 선언문은 런타임 이전에 함수 객체가 만들어진다
- `()` : 호출 연산자 (피연산자가 필요)
- 프로그래밍에서 lazy는 좋은 의미이다 (ex. lazy loading)
- 함수 내부에 오류가 있더라도 이 오류는 호출할 때 발생한다
  ```jsx
  function foo() {
    return x + 1;
  } // undefine
  foo(); // Error
  ```
- 함수 호출문은 제어문이다
  - 제어문이 없으면 코드는 위에서 아래로 흐르기만 한다
  - 함수가 호출되면 다시 위에 있는 함수 정의로 올라간다
- 함수는 객체로서 만들어지는데 그 객체로 되는 시점은 함수 정의가 평가되는 시점(런타임 이전) 이 것은 함수가 어떻게 만들어졌느냐에 따라 다르다
  - 함수 호출문은 런타임 이전일 것이고, 함수 표현식이였으면 런타임 때 평가되었을 것이다.
- object 란 subject가 인식할 수 있는 모든 것 (여기서 subject는 개발자)
- 객체란 프로퍼티(속성)들로 이루어져있다.
- 객체 지향은 무조건 좋다? X 상속은 무조건 좋다? X
- `[[Environment]]`: 상위 스코프에 대한 참조값. 함수객체만 가지고 있다.
- `[[Prototype]]`: 모든 객체가 가지고 있다.
- arguments 가 왜 있지? 존재 이유 ?
  - 매개변수를 선언 못하는 경우
  - 가변인자를 위해서 (예를들어 내가 작성한 숫자를 모두 더해라)
- node.js와 browser의 출력방식이 다른이유? browser는 ECMAscript를 따르지 않기 때문이다
- 유사배열?
  - length가 프로퍼티가 존재해야한다.
  - 프로퍼티 키가 0, 1, 2, 3, 4 처럼 인덱스처럼 생긴 ‘문자열‘이다.
- enumerable false인 애들은 브라우저에서 연한 글씨, true인 애들은 굵은 글씨
- 열거와 순회 차이? 순서가 의미있느냐(순회) 없느냐(열거)의 차이
  - 배열은 순서의 의미가 강하다 (index) ⇒ 순회
  - 배열은 순서의 의미가 없고 이름에 의미가 있다 (값을 가지고 오는 key) ⇒ 열거
- 화살표 함수는 arguments 객체가 없다
- arguments객체는 ES6부터 사용안하는 것을 권장
  - 스프레드를 사용하여 arguments를 배열로 쉽게 만들 수 있다 `[…arguments]`
  - rest parameter도 사용할 수 있다 `(…arg)`
  - document.querySelectorAll() 도 유사배열객체를 반환하는데 이것도 배열로 바꿔서 코딩하는 것이 더 좋다
- 유사 배열 객체 만든이유 순회를 하면서 자유자재로 메서드를 추가하기 위해서
  - 하지만 배열에는 충분히 좋은 메서드가 많아서 설계 오류인 듯 하다
- 생성자함수 쓰는 이유
  - 생성자 함수는 프로퍼티 구조가 동일한 객체를 여러개 생성할 때 유리하다. 라는 것 하나 밖에 없다.
- this에는 할당 못한다.
- 할당과 바인딩 차이?
  - 식별자와 값을 이어주는걸로, 거의 비슷한 개념.
  - this는 할당이 불가능하기 때문에 바인딩이라는 용어를 사용한다.
- 생성자 함수는 인스턴스를 여러개 찍어내는 만큼, 메서드도 여러번 생성이 됨.
  - 생성자 함수가 호출될 때마다 함수객체가 만들어짐.
  - 메모리가 낭비되고, 객체를 만드는것도 공짜가 아님. 시간복잡도와 공간복잡도 측면에서 다 마이너스.
  - 메서드를 한번만 만들어서 모든 인스턴스가 다 사용할 수 있도록 공유해서 쓰고싶다 → 프로토타입
- 상속의 필요? 함수의 재사용을 위해서..! 그 객체를 프로토타입이라 한다.
- 상속을 하는 이유는 재사용성때문인데, 함수를 상속하면 불필요한 인스턴스가 낭비된다. 인스턴스낭비를 막기 위해서, 부모의 프로토타입을 사용한다
- 상속은 상위에서 하위로는 되지만 반대로는 되지 않는다.
- this는 3가지 방식(일단 암기)
  - 일반 함수의 경우 전역 객체를 가리킴
  - 생성자 함수의 경우 생성될 인스턴스를 가리킴
  - 메서드의 경우 이 메서드를 호출한 객체를 가리킴(`.`앞에 있는 객체)

```jsx
function Person(name) {
  this.name = name;

  Person.prototype.sayHi = function () {
    console.log(`Hi! my name is ${this.name}.`);
    // 이러면 new 할때마다 이 메서드가 계속 생긴다.
  };
}

Person.prototype.sayHi = function () {
  console.log(`Hi! my name is ${this.name}.`);
  // 이렇게 해야 하나만 생성.
  // 근데 가독성의 측면에서 생성자 함수랑 같이있어야 된다.
  // 지금은 바로밑에 있지만 이거랑 위에 생성자함수 사이에 1000줄 코드 있으면?
  // 가독성 엄청나쁨. 그래서 두개모으고싶거든?
  // 이 두개를 딱 묶여있으면 좋겠다.

  // 즉시 실행 함수로 감싸면 묶을 수 있음.
};

const Person2 = (function () {
  function Person2(name) {
    this.name = name;
  }
  Person2.prototype.sayHi = function () {
    console.log(`Hi! my name is ${this.name}.`);
  };

  return Person2;
})();

const me = new Person2("Lee");
// 이렇게 하면 캡슐화가 된다. 그래도 아쉽다
// 그래서 클래스가 나온다.
```

- 함수는 인스턴스마다 달라지지 않기 때문에 올려야 하지만 프로퍼티 값은 각자 다르기 때문에 인스턴스가 각자 가져야 한다

## 느낀점

- 이 책에서 가장 중요한 첫번째가 for 반복문이고 두번째가 렉시컬 스코프라고 하셨다. 처음에는 왜 for문이 제일 중요한지 몰랐고 강사님은 for문을 거의 사용하지 않는다고 하셨는데, 수업을 듣고 생각해볼수록 for문은 변수 할당이 많이 일어나는 등의 비효율적이였고, 지금까지 for 반복문 대체할 수 있는 방법을 알고는 있었지만 일단 편하니까 for 문부터 사용해왔지 않나 반성이 되었다. 이는 코딩테스트 연습을 하며 생긴 나쁜 습관이기도 한데 어떻게 하면 코드를 ‘잘' 짤 수 있는지에 대해 생각해보아야겠다.
- 두번째로 중요한 렉시컬 스코프에 대해서도 또 얘기가 나왔는데 한 번 더 듣게되니 저번주에 렉시컬 스코프에 대해서 공부한 것에 이어서 확실히 정리가 되었다.
- 또한 기억에 남는 점은 유사 배열 객체 였는데, 배열이면 배열이지 유사 배열 객체는 뭐야..? 라고 생각이 되었지만 index순서와 length가 존재해서 배열의 메서드를 가지진 않았지만 순회가 가능하다는 점에서 그렇게 불렸다. 처음엔 이 유사 배열 객체가 신박하다고 생각이 되었지만 사실 배열의 메서드는 추가적으로 메서드를 만들지 않아도 될 정도로 훌륭한 메서드들이 많이 존재해서, 스프레드 등을 이용하여 배열로 바꿔서 사용하는 것을 보면 그닥 좋은 구조가 아닌 것이였다..
- 오늘은 내일 배울 프로토타입을 위한 기반을 배우게 되었는데 솔직히 어려웠지만 나만 그런 것이 아니라 모두 다 어려워하는 것이니 좌절하지말고 같이 공부하는 수강생들과 으쌰으쌰하며 열심히 공부해야겠다는 생각이 들었다!

## 참고사항

- [ASTexplorer](https://astexplorer.net/)
