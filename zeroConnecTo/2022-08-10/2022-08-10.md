# 2022/08/10

## 오늘 공부한 내용

### 타입 변환과 단축 평가

- 타입 변환 : 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것
    - 명시적 타입 변환 (타입캐스팅) : 개발자가 의도적으로 값의 타입을 변환하는 것
        
        ```jsx
        var x = 10;
        
        var str = x.toString() // typeof str : string
        // typeof x : number (원본 x의 타입은 변경되지 않는다)
        ```
        
        - 문자열 타입
            
            ```jsx
            // 1. String 생성자 함수
            String(1);
            // 2. Object.prototype.toString() 사용
            (1).toString()
            // 3. 문자열 연결 연산자를 이용
            1 + ''
            ```
            
        - 숫자 타입
            
            ```jsx
            // 1. Number 생성자 함수
            Number('1')
            // 2. parseInt, parseFloat 함수 사용
            parseInt('1')
            parseFloat('10.53')
            // 3. + 단항 산술 연산자를 이용
            +'1'
            // 4. * 산술 연산자를 이용
            '10.53' * 1
            ```
            
        
        - 불리언 타입으로 변환
            
            ```jsx
            // 1. Boolean 생성자 함수
            Boolean(0) // false
            Boolean(1) // true
            Boolean([]) // true
            // 2. ! 부정 논리 연산자를 두 번 사용
            ```
            
        
    
    - 암묵적 타입 변환 (타입 강제 변환) : 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 타입이 자동으로 변환되는 것
        
        ```jsx
        '10' + 2 // string "102"
        5 * "10" // number 50
        '1' > 0 // true
        ```
        
        - 단항 연산자( `+` )는 문자열이 하나 이상이면 문자열로 만든다. (문자열 연결 연산자로 동작한다.)
        - 산술 연산자 ( `-` , `*` , `/` )의 경우 숫자 값을 만든다.
        - 비교 연산자 ( `>` , `<` ), if, for문의 조건식의 경우 불리언 값을 만든다
            - `[]` 의 경우
                
                ```jsx
                +[] // 0
                if([]) console.log(true) // true
                ```
                
    
    - 자신이 작성한 코드에서 암묵적 타입 변환이 일어나는지, 어떤 타입으로 변환되는지, 결론적으로 어떻게 평가될 것인지 예측 가능해야 한다.
    
- 단축 평가
    - 논리곱 연산자(`&&`)와 논리합 연산자(`||`)는 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환한다.
    - 즉, 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 말한다.
    
    | 단축 평가 표현식 | 평가 결과 |  |
    | --- | --- | --- |
    | true || anything | true | 앞이 true 면 true를 출력 |
    | false || anything | anything | 앞이 false 면 뒤를 출력 |
    | true && anything | anything | 앞이 true 면 뒤를 출력 |
    | false && anything | false | 앞이 false 면 false를 출력 |
    

### 객체 리터럴

- 객체란?
    - 다양한 타입의 값(원시 값이나 다른 객체)을 하나의 단위로 구성한 복잡한 자료구조
    - 원시 값은 변경 불가능하지만, 객체는 변경 가능한 값이다.
    - 객체는 프로퍼티로 구성되고 프로퍼티는 키와 값으로 구성된다.
    - 0개 이상의 프로퍼티로 구성된다.
    
- 프로퍼티란?
    - 프로퍼티 키는 프로퍼티를 식별하기 위한 식별자(identifier)이다.
    - 메서드란 객체에 묶여있는 함수를 의미한다.
        
        (프로퍼티의 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라 부른다)
        
    - 프로퍼티를 확인할 경우에는 대괄호 안에 들어가는 키값을 `""`로 묶어줘야 한다

### 원시 값과 객체의 비교

- 원시 타입(primitive type) 값
    - 변경 불가능한 값(immutable value)
    - 원시 값을 변수에 할당하면 확보된 메모리 공간에는 실제 값이 저장된다
    - 변경 불가능 하다는 뜻은 한 변수에 다른 값을 할당하면 그 값이 변경되는 것이 아닌 다른 값에 대한 메모리를 할당한 후 변수는 그 메모리를 가리키게 된다.
    - 즉, 변수 값을 변경하기 위해서는 원시 값을 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다.
    
- 객체 타입(object type) 값
    - 변경 가능한 값(mutable value)
    - 객체를 변수에 할당하면 확보된 메모리 공간에는 참조 값이 저장된다.
    - 즉, 값이 저장된 메모리의 주소를 공유하기 때문에 한 곳에서 값을 바꾸면 참조하고 있는 모든 곳에 영향이 간다.
    - 깊은 복사, 얕은 복사

## 부족한 부분

- `+""`는 명시적인지 암묵적인지?
- 객체 안에 객체가 있는 경우 따로 주소를 가지고 있는건가?

## 느낀점

- 러버덕을 해보니 머릿속의 내용을 말로 표현이 안되서 답답함을 느꼈다. 하지만 러버덕을 하면서 정확히 어떤 부분을 모르는지 알 수 있었고, 모호한 부분도 말을 하면서 정리가 되었다. 또한 모르는 부분은 조원들과 함께 알아보면서 공부하였는데 확실히 혼자 공부하는 것보다 확실히 더 도움이 되었다.