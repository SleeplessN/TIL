# 23장. 실행 컨텍스트

> **실행 컨텍스트(execution context)는 자바스크립트 동작 원리를 담고 있는 핵심 개념이다.**

- 실행 컨텍스트를 바르게 이해한다면 다음 내용들을 이해할 수 있다.
  - 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값(식별자 바인딩)을 관리하는 방식
  - 호이스팅이 발생하는 이유
  - 클로저의 동작 방식
  - 태스크 큐와 함께 동작하는 이벤트 핸들러
  - 비동기 처리의 동작 방식

## 소스코드의 타입

- ECMAScript 사양은 소스코드(ECMAScript code)를 4가지 타입으로 구분한다.
- 이 4가지 타입의 소스코드가 실행 컨텍스트를 생성한다

| 소스코드의 타입           | 설명                                                                                           |
| ------------------------- | ---------------------------------------------------------------------------------------------- |
| 전역 코드 (global code)   | 전역에 존재하는 소스코드.전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다           |
| 함수 코드 (function code) | 함수 내부에 존재하는 소스코드.함수 내부에 중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다 |
| eval 코드 (eval code)     | 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스코드                               |
| 모듈 코드 (module code)   | 모듈 내부에 존재하는 소스코드.모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다        |

1. **전역 코드**
   - 전역 코드는 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성해야 한다.
   - `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩 하고 참조하기 위해 전역 객체와 연결되어야 한다.
   - 이를 위해 전역 코드가 평가되면 전역 실행 컨텍스트가 생성된다
2. 함수 코드
   - 함수 코드는 지역 스코프를 생성하고 지역 변수, 매개 변수, `arguments` 객체를 관리해야 한다.
   - 생성한 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 한다.
   - 이를 위해 함수 코드가 평가 되면 함수 실행 컨텍스트가 생성된다
3. `eval` 코드
   - `eval` 코드는 `strict mode`(엄격 모드)에서 자신만의 독자적인 스코프를 생성한다.
   - 이를 위해 `eval` 코드가 평가되면 `eval` 실행 컨텍스트가 생성된다.
4. 모듈 코드
   - 모듈 코드는 모듈별로 독립적인 모듈 스코프를 생성한다.
   - 이를 위해 모듈 코드가 평가되면 모듈 실행 컨텍스트가 생성된다.

## 소스코드의 평가와 실행

- 자바스크립트 엔진은 소스코드를 **소스코드의 평가**와 **소스코드의 실행** 과정으로 나누어 처리한다.
- **소스코드의 평가**
  - **실행 컨텍스트를 생성**한다
  - **변수, 함수 등의 선언문만 먼저 실행**하여 생성된 변수나 함수 식별자를 키로 **실행 컨텍스트가 관리하는 스코프**(렉시컬 환경의 환경 레코드)**에 등록**한다
- **소스코드의 실행**
  - 소스코드의 평가 과정이 끝나면 선언문을 제외한 소스코드가 순차적으로 실행된다. (즉, 런타임이 시작)
  - 이 때, **소스코드 실행에 필요한 정보**, 즉 변수나 함수의 참조를 **실행 컨텍스트가 관리하는 스코프에서 검색해서 취득**한다.
  - 그리고 변수 값의 변경 등 **소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록**된다.

<img src="./23장 실행 컨텍스트-images/Untitled.jpeg" width="500">

## 실행 컨텍스트의 역할

- 다음 예제는 **전역 코드**와 **함수 코드**로 구성되어 있다.
- 자바스크립트 엔진이 예제를 어떻게 평가하고 실행하는지 살펴보자!

```jsx
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(10);

// 메서드 호출
console.log(x + y); // 3
```

1. **전역 코드 평가**
   - 전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드를 실행하기 위한 **준비 단계**이다.
   - 소스 코드 평가 과정에서는 **선언문만 먼저 실행**한다.
     - 즉, **변수 선언문과 함수 선언문이 먼저 실행**된다.
   - 그 결과 생성된 전역 변수와 전역 함수가 **실행 컨텍스트가 관리하는 전역 스코프에 등록**된다.
   - 이 때, `var` 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 프로퍼티와 메서드가 된다.
2. **전역 코드 실행**
   - 전역 코드 평가 과정이 끝나면 **런타임이 시작**되어 전역 코드가 **순차적으로 실행**된다.
   - 이 때, **전역 변수에 값이 할당되고 함수가 호출**된다.
     - 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 **일시 중단**하고 코드 실행 순서를 변경하여 함수 내부로 진입힌다.
3. **함수 코드 평가**
   - 함수 호출에 의해 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치며 함수 코드를 실행하기 위한 **준비 단계**이다.
   - 함수 코드 평가 과정에서는 매개변수와 지역 변수 **선언문이 먼저 실행**된다.
   - 그 결과 생성된 매개변수와 지역 변수가 **실행 컨텍스트가 관리하는 지역 스코프에 등록**된다.
   - 또한, 함수 내부에서 지역변수처럼 사용할 수 있는 `**arguments` 객체가 생성되어 지역 스코프에 등록**되고 `**this` 바인딩도 결정\*\*된다.
4. **함수 코드 실행**
   - 함수 코드 평가 과정이 끝나면 **런타임이 시작**되어 함수 코드가 **순차적으로 실행**된다.
   - 매개변수와 지역변수에 **값이 할당**된다
   - `**console.log` 메서드가 호출\*\*된다.
     - `console.log` 메서드를 호출하기 위해 먼저 식별자인 console을 스코프 체인을 통해 검색한다.
       - 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다.
       - console 식별자는 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다.
       - 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프를 통해 검색 가능해야 한다는 것을 의미한다.
     - 다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다.
     - 이 후 인수로 전달된 표현식 `a+x+y`가 평가된다.
       - `a`, `x`, `y` 식별자는 스코프 체인을 통해 검색한다.
   - `console.log` 메서드의 실행이 종료되면 **함수 코드 실행 과정이 종료**되고 함수 호출 이전으로 되돌아가 **전역 코드 실행을 계속한다.**

- 이처럼 코드가 실행되려면 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다.

1. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다.
2. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하여 식별자를 검색할 수 있어야 한다.
3. 현재 실행 중인 코드의 실행 순서를 변경(ex. 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다.

- 이 모든 것을 관리하는 것이 바로 **실행 컨텍스트**이다!!

> ⭐️ **실행 컨텍스트**

1. 소스코드를 실행하는데 필요한 환경을 제공
   👉 식별자와 스코프는 실행 컨텍스트의 **렉시컬 환경**으로 관리
2. 코드의 실행 결과를 실제로 관리
   👉 코드 실행 순서는 **실행 컨텍스트 스택**으로 관리
   실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다
   >

## 실행 컨텍스트 스택

> **생성된 실행 컨텍스트는 스택(stack) 자료구조로 관리**되고, 이를 **실행 컨텍스트 스택**이라 한다.

- 다음 예제를 살펴보자

```jsx
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();
```

<img src="./23장 실행 컨텍스트-images/Untitled.png" width="600">

1. **전역 코드의 평가와 실행**
   - (자바스크립트 엔진은) 전역 코드를 평가하여
     - **전역 실행 컨텍스트를 생성**하고,
     - **실행 컨텍스트 스택에 푸시**한다.
   - 이 때, 전역 변수 x와 전역 함수 foo는 `전역 실행 컨텍스트`에 등록된다.
   - 이 후, 전역 코드가 실행되면 전역 변수 x에 값이 할당되고 전역 함수 foo가 호출된다.
2. **foo 함수 코드의 평가와 실행**
   - 전역 함수 foo가 호출되면 **전역 코드의 실행은 일시 중단**, **코드의 제어권이 foo 함수 내부로 이동**
   - foo 함수 내부의 함수 코드를 평가하여
     - **foo 함수 실행 컨텍스트를 생성**하고,
     - **실행 컨텍스트 스택에 푸시**한다.
   - 이 때, foo 함수의 지역변수 y와 중첩 함수 bar가 `foo 함수 실행 컨텍스트`에 등록된다.
   - 이 후. foo 함수 코드가 실행되면 지역 변수 y에 값이 할당되고 중첩 함수 bar가 호출된다.
3. **bar 함수 코드의 평가와 실행**
   - 중첩 함수 bar가 호출되면 **foo 함수 코드의 실행은 일시 중단**, **코드의 제어권이 bar 함수 내부로 이동**
   - bar 함수 내부의 함수코드를 평가하여
     - **bar 함수 실행 컨텍스트를 생성**하고 ,
     - **실행 컨텍스트 스택에 푸시**한다.
   - 이 때, bar 함수의 지역 변수 z가 bar 함수 실행 컨텍스트에 등록된다.
   - 이 후, bar 함수 코드가 실행되면 지역 변수 z에 값이 할당되고 console.log 메서드를 호출하고 종료된다.
4. **foo 함수 코드로 복귀**
   - bar 함수가 종료되면 **코드의 제어권은 다시 foo 함수로 이동**
   - 이 때, bar 함수 실행 컨텍스트를 **실행 컨텍스트 스택에서 pop하여 제거**
   - 이 후, foo 함수는 더 이상 실행할 코드가 없으므로 종료된다.
5. **전역 코드로 복귀**
   - foo 함수가 종료되면 **코드의 제어권은 다시 전역 코드로 이동**
   - 이 때, foo 함수 실행 컨텍스트를 **실행 컨텍스트 스택에서 pop하여 제거**
   - 이 후, 더 이상 실행할 전역 코드가 없으므로 **전역 실행 컨텍스트도 pop되어 제거**
   - 최종적으로 실행 컨텍스트 스택에는 아무것도 남지 않게 된다.

> ⭐️ 이처럼 **실행컨텍스트**는
> 👉 **코드의 실행 순서를 관리**한다
> 👉 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트다.
> 👉 따라서, 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 **실행 중인 실행 컨텍스트**라 부른다

## 렉시컬 환경

> **렉시컬 환경**은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트다.
> 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 한다.

- 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다.
- 실행 컨텍스트는 `LexicalEnvironment` 와 `VariableEnvironment` 컴포넌트로 구성된다
  - 이 두 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다.
  - 두 컴포넌트의 내용이 달라지는 경우가 있지만 구분하지 않고 렉시컬 환경으로 통일해서 설명하겠다
- 렉시컬 환경은 두 개의 컴포넌트로 구성된다
  1. 환경 레코드 (Environment Record)
     - 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소이다.
  2. 외부 렉시컬 환경에 대한 참조 (Outer Lexical Environment Reference)
     - 상위 스코프를 가리킨다.
     - 이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 사위 코드의 렉시컬 환경을 말한다.
     - 단방향 링크드 리스트인 스코프 체인을 구현한다.

<img src="./23장 실행 컨텍스트-images/Untitled%201.png" width="500">

## 실행 컨텍스트의 생성과 식별자 검색 과정

### 전역 객체 생성

- 전역 객체는 **전역 코드가 평가되기 이전에 생성**된다.
- 전역 객체는 빌트인 전역 프로퍼티, 빌트인 전역 함수, 표준 빌트인 객체를 포함한다.
- 환경에 따라 WebAPI 또는 호스트 객체를 포함한다.
  - 호스트 객체란 window, global 등 호스트 환경에서 정의된 객체를 말한다.

### 전역 코드 평가

- 전역 코드 평가 과정은 다음과 같다

<img src="./23장 실행 컨텍스트-images/Untitled%202.png" width="500">

- 다음 예제와 함께 진행하도록 한다.

```jsx
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);
```

1. **전역 실행 컨텍스트 생성**
   - 먼저 비어있는 전역 실행 컨텍스트를 생성, 실행 컨텍스트 스택에 푸시
   - 이때 전역 실행 컨텍스트는 실행 중인 실행 컨텍스트(실행 컨텍스트 스택의 최상위)가 된다.
2. **전역 렉시컬 환경 생성**
   - 전역 렉시컬 환경을 생성, 전역 실행 컨텍스트에 바인딩한다.
   - 렉시컬 환경은 **`환경 레코드`**와 **`외부 렉시컬 환경에 대한 참조`**라는 2개의 컴포넌트로 구성.

- 2-1. **전역 환경 레코드 생성**
  - `let`과 `const`가 등장한 ES6부터 `let`과 `const`로 선언한 전역 변수를 구분하기 위해서 선언적 환경 레코드가 새로 등장했다.
    - 2-1-1. **객체 환경 레코드 생성**
      - 객체 환경 레코드는 `BindingObject`라는 객체와 연결되어 전역 객체의 프로퍼티와 메서드가 된다.
      - 전역 코드 평과 과정에서 `var` 키워드로 선언된 전역 변수와 함수 선언문이 이에 해당된다.
    - 2-1-2. **선억적 환경 레코드 생성**
      - `let`, `const` 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록에 존재하는데 그 개념적인 블록에 해당하는 공간이다.
      - `선언 단계`와 `초기화 단계`가 분리 되어 진행하므로 **일시적 사각지대(TDZ)**가 존재한다.
- 2-2. **this 바인딩**
  - 전역 환경 레코드의 `[[GlobalThisValue]]` 내부 슬롯에 `this`가 바인딩된다.
  - 일반적으로 전역 코드에서 this는 전역 객체를 가리키므로 전역 환경 레코드의[[GlobalThisValue]] 내부 슬롯에는 **전역 객체가 바인딩**된다.
- 2-3. **외부 렉시컬 환경에 대한 참조 결정**
  - 외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 스코프의 렉시컬 환경, 즉 상위 스코프를 가리킨다.
  - 이를 통해 **단방향 링크드 리스트인 스코프 체인을 구현**한다.

### 전역 코드 실행

- 전역 코드가 순차적으로 실행되기 시작. 변수 할당문이 실행되어 전역 변수 `x`, `y`에 값이 할당

- 변수 할당문이나 함수 호출문을 실행하려면 변수 또는 함수 이름이 선언된 식별자인지 확인해야 한다.
  - 어느 스코프의 식별자를 참조하면 되는지 결정하는 **식별자 결정**이 진행된다.
  - **식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작**
    한다.

### foo 함수 코드 평가

- 함수 코드 평가는 다음과 같다

1. 함수 실행 컨텍스트 생성
2. 함수 렉시컬 환경 생성

- 2.1 함수 환경 레코드 생성
- 2.2 this 바인딩
- 2.3 외부 렉시컬 환경에 대한 참조 결정

1. 함수 실행 컨텍스트 생성
   - foo 함수 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시된다.
2. 함수 렉시컬 환경 생성
   - foo 함수 렉시컬 환경을 생성하고 foo 함수 실행 컨텍스트에 바인딩 한다.
   - 이 또한 마찬가지로 `환경 레코드`와 `외부 렉시컬 환경에 대한 참조`로 구성된다

- 2.1 함수 환경 레코드 생성
  - 다음을 등록하고 관리한다
    - 매개변수
    - arguments 객체
    - 함수 내부에서 선언한 지역 변수와 중첩 함수
- 2.2 this 바인딩
  - `[[ThisValue]]` 내부 슬롯에 `this`가 바인딩된다.
  - `this`는 함수의 호출 방식에 따라 달라진다.
  - 이번 경우에는 일반 호출이므로 `this`는 전역 객체를 가리키게 되고, 즉 `[[ThisValue]]`에는 전역 객체가 바인딩 된다.
- 2.3 외부 렉시컬 환경에 대한 참조 결정
  - 함수를 어디서 호출했는지가 아닌 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
  - 즉 함수 객체는 자신이 정의된 스코프, 즉 상위 스코프를 기억한다.
  - 이 상위 스코프를 `[[Environment]]`에 저장한다.
  - 이 `[[Environment]]`가 렉시컬 스코프를 구현하는 매커니즘이다.

### foo 함수 코드 실행

- 런타임이 시작되어 `foo` 함수의 소스코드가 순차적으로 실행되기 시작한다
  - 매개 변수에 인수가 할당, 변수 할당문이 실행되어 지역 변수에 값이 할당, 그리고 함수 `bar`가 호출
  - 이때 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작.

### bar 함수 코드 평가

- 평가 순서는 `foo` 함수 코드 평가와 동일하다.
  - `bar` 함수 또한 일반 함수로 호출이 되었으므로 `this` 는 전역 객체에 바인딩된다.

### bar 함수 코드 실행

- 런타임이 시작되어 bar 함수의 소스코드가 순차적으로 실행되기 시작한다.

  - bar 함수의 경우에는 매개변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 z에 값이 할당된다.

- `console.log(a + b + x + y + z)`의 실행
  1. `console` 식별자 검색
     - 스코프 체인에서 console 식별자를 검색
     - 스코프 체인을 따라 가보니 전역 렉시컬 환경에 존재
  2. `log` 메서드 검색
     - 프로토타입 체인을 통해 메서드를 검색
     - `log`는 `console` 객체 자체에서 소유하는 메서드이다.
  3. 표현식 a + b + x + y + z 의 평가
     - 이를 평가하기 위해서 a, b, x, y, z 식별자를 검색
     - 식별자는 스코프 체인을 통해서 이루어짐
  4. console.log 메서드 호출
     - 표현식이 평가되어 생성한 값 42를 `console.log` 메서드에 전달하여 호출

### bar 함수 코드 실행 종료

- 더 이상 실행할 코드가 없으므로 bar 함수 코드의 실행이 종료
- 실행 컨텍스트 스택에서 pop 처리 되면서 제어권이 다시 foo 함수로 넘어간다.

### foo 함수 코드 실행 종료

- foo 함수 또한 더 이상 실행할 코드가 없으므로 실행이 종료
- 실행 컨텍스트 스택에서 pop 처리 되면서 제어권이 다시 전역 코드로 넘어간다.

### 전역 코드 실행 종료

- 더 이상 실행할 코드가 없으므로 전역 코드 실행 종료
- 실행 컨텍스트 스택에서 pop 처리 되면서 실행 컨텍스트 스택은 비게 된다.

## 실행 컨텍스트와 블록 레벨 스코프

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 함수 레벨 스코프를 따른다
- let, const 키워드로 선언한 변수의 경우는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
- 다음 예제를 살펴보자.

  ```jsx
  let x = 1;

  if (true) {
    let x = 10;
    console.log(x); // 10
  }

  console.log(x); // 1
  ```

  - **if 함수 실행**
    - 새로운 렉시컬 환경을 생성하여 기존의 렉시컬 환경을 교체
  - **if 함수 실행 종료**

    - 실행이 종료되면 이전 렉시컬 환경으로 복귀한다.
      > eval, 모듈을 제외하고 `전역 코드`와 `함수 코드`만이 **새로운 실행 컨텍스트를 생성**했다.
      > 때문에 **함수를 제외한 코드 블록은 새로운 실행 컨텍스트를 생성하지 않는다.**
      > 대신 블록 렉시컬 환경은 만들고, 해당 실행 컨텍스트에 바인딩 되어, 실행되는 동안만 교체된다
